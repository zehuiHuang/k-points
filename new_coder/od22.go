package main

import (
	"bufio"
	"fmt"
	"os"
)

// 最大数字

/*
*
题目描述
给定一个由纯数字组成以字符串表示的数值，现要求字符串中的每个数字最多只能出现2次，超过的需要进行删除；
删除某个重复的数字后，其它数字相对位置保持不变。
如”34533″，数字3重复超过2次，需要删除其中一个3，删除第一个3后获得最大数值”4533″
请返回经过删除操作后的最大的数值，以字符串表示。

输入描述
第一行为一个纯数字组成的字符串，长度范围：[1,100000]

输出描述
输出经过删除操作后的最大的数值
*/

/*
*
输入	34533
输出	4533
*/
func main22() {
	//思路：
	//理解：题中的要求是字符串最多有两个重复的，多的就需要删掉，在选择删除哪个有要求，就是删掉后能保证整体数字最大
	//首先要考虑清楚删掉一个数字什么情况下会使原数字变小或变大（都减少相同位数），就是删除的这个值的右边要比当前值大
	//（比如342中删掉3后4开头肯定变大了，但又比如324中的3如果要删掉那么就是2开头了，明显会变小）

	//针对这种判定当前值和右边的值的大小的有一套数据结构公式：单调栈。
	//循环该字符串数组，如果发现栈顶的元素比当前值大，那么就不要出栈（出栈后数会变小），如果栈顶的元素要比当前值小
	//，在保证后续的遍历中该数字还会最终保留两个，那么就可以提前把该值出栈（也是删掉了意思）
	//在遍历的过程中，如果发现当前数组已经满足了最大值是2了，那么就可以忽略当前值了

	scanner := bufio.NewScanner(os.Stdin)
	scanner.Scan()
	s := scanner.Text()

	//已经保留数字的数量
	mp1 := make(map[rune]int)
	//数字待使用的数量
	mp2 := make(map[rune]int)

	for i := range s {
		mp1[rune(s[i])] = 0
		mp2[rune(s[i])] += 1
	}
	//栈结构，存储的就是去掉重复最多留两个的结果
	stack := []rune{}
	for i := range s {
		c := s[i]
		//如果已包括了两个相同的数字了，那么后面的都移除掉即可
		if mp1[rune(c)] == 2 {
			mp2[rune(c)] -= 1
			continue
		}
		for len(stack) > 0 {
			top := stack[len(stack)-1]
			//表示如果删掉这一个，那么还剩下的如果>=2才能出栈
			count := mp1[top] + mp2[top] - 1
			if rune(c) > top && count >= 2 {
				//要弹出删掉
				stack = stack[:len(stack)-1]
				mp1[top] -= 1
			} else {
				//跳出当前循环，让当前值加入到栈
				break
			}
		}

		stack = append(stack, rune(c))
		mp1[rune(c)] += 1
		mp2[rune(c)] -= 1
	}
	fmt.Println(string(stack))
}
