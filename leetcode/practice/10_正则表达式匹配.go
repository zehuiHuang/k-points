package practice

//https://leetcode.cn/problems/regular-expression-matching/solutions/24543/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/?envType=study-plan-v2&envId=selected-coding-interview
/*
*
给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖 整个 字符串 s 的，而不是部分字符串。

示例 1：

输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
示例 2:

输入：s = "aa", p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
示例 3：

输入：s = "ab", p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）
*/

/*
*
思路:动态规划
dp[i][j] 表示 s 的前 i-1  个是否能被 p 的前 j-1 个匹配
前提:已知dp[i-1][j-1]已经匹配了,那么对s[i]和p[i]进行处理
考虑三种情况:
1、s[i]=p[j] ,那么dp[i][j]=dp[i-1][j-1]
2、s[i]!=p[j] 并且 p[j]=“.” ,那么dp[i][j]=dp[i-1][j-1]
3、s[i]!=p[j]并且p[j]=“*” ,那么又分两种情况:

比如 (s=ab,p=abc *)
1)、p[j-1]!=s[i] ,那么dp[i][j]=dp[i][j-2],即将*前面的字符串去掉,也就是*前面字符有0个 c*直接移除

比如 (s=abc,p=abc *) 或 比如 (s=ab,p=ab .*)
2)、p[j-1]==s[i] 或p[j-1] == ".",那么只要满足下面一个就算匹配:
dp[i][j]=dp[i-1][j] || dp[i][j-1] || dp[i][j-2]

dp[i][j]=dp[i][j-1] 表示c* 是多个c 例如:(s=abc,p=abc *)
dp[i][j]=dp[i][j-1] 表示c* 是单个c 例如:(s=abc,p=ab.*)
dp[i][j]=dp[i][j-2] 表示c* 是没有c,直接去掉了 例如:(s=ab,p=abc *)
*/
func isMatch(s string, p string) bool {
	m, n := len(s), len(p)
	dp := make([][]bool, m+1)
	for i := range dp {
		dp[i] = make([]bool, n+1)
	}

	// 初始化
	dp[0][0] = true

	// 初始化第一行：处理模式串中 * 匹配0次的情况
	for j := 1; j <= n; j++ {
		if p[j-1] == '*' {
			dp[0][j] = dp[0][j-2]
		}
	}

	// 状态转移
	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			// 当前字符匹配
			if s[i-1] == p[j-1] || p[j-1] == '.' {
				dp[i][j] = dp[i-1][j-1]
			} else if p[j-1] == '*' {
				// 处理 * 的情况
				// 情况1：* 匹配0次（跳过前一个字符）
				dp[i][j] = dp[i][j-2]

				// 情况2：* 匹配1次或多次（如果前一个字符匹配）
				if p[j-2] == s[i-1] || p[j-2] == '.' {
					dp[i][j] = dp[i][j] || dp[i-1][j]
				}
			}
		}
	}

	return dp[m][n]
}

/*
   dp五部曲:
   设主串s的长度为m,设模式串p的长度为n;其中s只有小写字母,p有字母/./*
   1.状态定义:dp[i][j]为考虑s[0,i-1]与p[0,j-1]是否能匹配上,能匹配上就为true
   2.状态转移:若要求dp[i][j]就必须考虑到s[i-1]与p[j-1]
       2.1 当p[j-1]不是'*'时
           2.1.1 若s[i-1]==p[j-1]时,即p[j-1]为'a'-'z'且与s[i-1]相等,看dp[i-1][j-1]
           2.1.2 p[j-1] == '.'时,直接将'.'变成s[i-1],看dp[i-1][j-1]
           注意:这里的'.'是匹配一个字符,而不是一连串,如"a.b"->"axb"
       2.2 当p[j-1]是'*'时,主要看p[j-2]做判断
           2.2.1 p[j-2]为'a'-'z'并且p[j-2]==s[i-1],那么此时s继续往前看,p暂时不动
               即:看dp[i-1][j]
           2.2.2 p[j-2]为'.',那么".*"可以变为"....."可以匹配s[i-1]前面的任何字符(万能串)
               因此,直接看dp[i-1][j](或者直接返回true)
           2.2.3 剩下的就是p[j-2]为'a'-'z'且p[j-2]!=s[i-1],那么此时p的"x*"作废,看dp[i][j-2]
       这里:2.1.1与2.2.2可以看成一种情形:即s与p均前移一位
           2.2.1与2.2.2可以看成一种情形:即p不动s前移一位
   3.初始化:
       3.1 空的s
           3.1.1 空的p,空的s可以匹配空的p,因此dp[0][0]=true
           3.1.2 非空的p,空的s可能可以匹配非空的p,例如"a*",因此需要经过转移计算
       3.2 空的p
           3.2.1 空的s,同3.1.1
           3.2.2 非空的s,空的p不可能匹配非空的s,因此dp[i][0]=false,i∈[1,m]
       3.3 非空的s与非空的p:需要经过转移计算
       其中:3.1.1与3.2.2可以合并为dp[i][0]=i==0
   4.遍历顺序:显然是正序遍历
   5.返回形式:返回dp[m][n]就是考虑s[0,m-1]与p[0,n-1]是否能匹配上
*/

/**
class Solution {
public boolean isMatch(String s, String p) {
int m = s.length(), n = p.length();
boolean[][] dp = new boolean[m + 1][n + 1];
// 初始化dp[i][0]
// for(int i = 0; i <= m; i++) {
//     dp[i][0] = i == 0;
// }
dp[0][0] = true;
// i从0开始
for(int i = 0; i <= m; i++) {
// 注意j从1开始
for(int j = 1; j <= n; j++) {
if(p.charAt(j - 1) != '*') {
// 1.当p[j-1]不是'*'时(注意j已经从1开始了)
// 这里要注意运算优先级问题(加括号)
if(i >= 1 && (s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.')) {
// s与p均前移一位
dp[i][j] = dp[i - 1][j - 1];
}
} else {
// 2.当p[j-1]是'*'时,主要看p[j-2]做判断
if(j >= 2 && i >= 1 &&
(p.charAt(j - 2) == s.charAt(i - 1) || p.charAt(j - 2) == '.')) {
// 看"x*":p不动s前移一位
dp[i][j] = dp[i - 1][j];
}
// 不看"x*":
// 剩下的为p[j-2]为'a'-'z'且p[j-2]!=s[i-1],那么此时p的"x*"作废,看dp[i][j-2]
if(j >= 2) {
dp[i][j] |= dp[i][j - 2];
}
// 这里的|=表示只要满足了其中一个条件就可以使得dp[i][j]==true
// 通俗一点的解释就是:当p[j-1]=='*'时,
// 若p[j-2]==s[i-1]||p[j-2]=='.',则dp[i][j]可以继承dp[i-1][j]:转移路径1
// 若p[j-2]!=s[i-1],则dp[i][j]可以继承dp[i][j-2]:转移路径2
// 满足任意一条转移路径就可以使得dp[i][j]=true
}
}
}
// 所求即为考虑s[0,m-1]与p[0,n-1]是否能匹配上
return dp[m][n];
}
}
*/
