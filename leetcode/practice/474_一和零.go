package practice

/**
给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。

如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。

示例 1：
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
*/

/*
*
思路:动态规划:01背包,物品的重量是由两个维度来控制的
//dp[i][j]:背包容量为xy(x个0和y个1)最多能装多少个物品,当前物品的重量(两个维度:x个0和y个1)
//01背包:dp[i][j]=max(dp[i][j],dp[i-x][j-y]+1)
*/
func findMaxForm(strs []string, m int, n int) int {
	//定义dp
	dp := make([][]int, m+1)
	for i := range dp {
		dp[i] = make([]int, n+1)
	}
	//初始化-都为0
	//遍历物品
	for _, v := range strs {
		//计算出物品的重量(两个维度)
		x, y := 0, 0
		for i := 0; i < len(v); i++ {
			if v[i] == '0' {
				x++
			} else {
				y++
			}
		}
		//遍历背包,倒叙遍历
		for i := m; i >= x; i-- {
			for j := n; j >= y; j-- {
				//减去物品,然后+1(因为统计的是物品数量)
				dp[i][j] = max(dp[i][j], dp[i-x][j-y]+1)
			}
		}
	}
	return dp[m][n]
}
