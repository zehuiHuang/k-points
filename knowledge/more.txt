每天新得

Xxxx-xxxx
python相关：
poetry包管理:https://juejin.cn/post/7092386598033031176
常用命令：
poetry new my-project 、 poetry init 和poetry install

python多版本控制：pyenv
pyenv install 3.x.x
pyenv install —list
pyenv versions


golang：
1、技巧：自定义一个类型（为一个函数func），并实现某些接口，并将某一个相同签名的函数转化为这个自定义类型，那么就将这个普通函数赋予了额外的能力（因为同类型的实现了某接口能力）
2、类型转化：显示转化比如int(str) ,    x.(T):这种转化必须是接口

算法：
1、链表类：相交链表、反转链表、回文链表


2025-0506——————————————
Git工作流
主要分支：master、develop
辅助分支：feature-*、release-*、hotfix-*
1、featrue-*分支从develop分支拉取创建、完成后需合并回develop(注：意味下一次的发布要包含该新功能)
2、hotfix-*分支从master分支拉取创建，完成后合并回master和develop(注：若此时存在release-*分支，则需合并至release-*而非develop)
3、release-*分支从develop分支拉取创建，完成后需合并回master和develop，并在master分支上打tag
4、辅助分支完成合并后，要全部删掉

CI/CD和DevOps：
teckton的部署流程
xxxxZadig的使用xxxx


2025-0507——————————————
Auto-GPT和AgentGPT的搭建和使用
Langchain框架的基本使用：模型调用、提示词模版、返回结构限制和校验、RAG技术

2025-0508——————————————
Langchain的高级用法：Memory、Agent
(长期记忆和短期记忆)
SerpApi工具
LangGraph:工作流、并行工作流

2025-0509——————————————
LangGraph的基本用法：聊天机器人+工具使用+添加内存（支持上下文、多伦对话）+人工干预（人机协同）



2025-0512——————————————
LangGraph部署

2025-0519——————————————
1、Python 的uv工具使用
uv init my_project
uv add xx
包管理：uv pip install xx
Python版本管理：uv python install 3.10 3.11
执行脚本：uv run example.py
2、mcp的python sdk使用
分类：服务、资源、工具、图像、上下文、认证
调试：mcp dev server.py
部署到claude中等：mcp install server.py
3、java新特性和使用技巧
函数式编程：Consumer<Object>：接受一个入参且不返回参数，Function<Object,Object>:一个入参一个出参，Supplier<Object>:无参数且只有一个返回值；Predicate<Object>:接受一个参数且返回boolean类型返回值。
CompletableFutrue:pulsar消息发送用到了
泛型的使用：
流Stream：flatMap扁平化处理；reduce归为一个值；parallelStream
Optional的使用：
响应式编程WebFlux的demo实践



golang面试准备———————

AI相关：langchain使用、mcp、智能体

模型调用、提示词模版、返回结构限制和校验、RAG技术、Memory、Agent
聊天机器人+工具使用+添加内存

基础相关：map、defer、gmp

项目经验：AI网关：master、worker架构；多维度限流、接口抽象（认证和大模型访问处理）、优先级队列、监控等、配置加载顺序、apollo、多环境部署和数据同步、资源隔离
自我介绍：— 目前在哪，技术栈（java、golang）项目经验（网关、ai相关、大数据相关、、动参、工具相关）




2025-0603——————————————
Mysql相关：
1、回顾B+树索引
主键索引：按照主键B+树结构
非主键索引（一个或多字段）结构：按照字段创建索引B+树：key为字段值（左匹配原则），值为ID，通过回表查询实际的行数据。
覆盖索引：查询的列只包含主键和索引列
前缀索引：定义索引时定义索引长度（弊端：无法使用覆盖索引了，但好处是节省了空间）
普通索引和唯一索引的区别：
2、回顾mysql日志
Redo Log：即WAL日志(磁盘顺序写生成page)，为了解决mysql当机导致缓冲池Buffer Pool不能刷新到磁盘的问题，保证了持久性

Undo Log：即回滚日志(类似写时复制)，保证了事务的原子性、隔离性
3、回顾之前写的算法题

4、整理好面试自我介绍部分
介绍技术栈为java和golang、介绍项目（大家保险的和金山的）、介绍组件：比如langchain4j、消息中心、规范性(git-flow工作流的指定、golang的单元测试、配置文件加载顺序等)、管理方法

2025-0604——————————————面试
1、kafka原理和使用场景：分区partitions、多副本存储、消费者组、跨分区无序(零拷贝、顺序读写、页缓存、批量处理、数据压缩 )
2、分布式技术原理：数据强一致性（TCC两阶段提交）、最终一致性、BASE和CAP概念和原理：案例redis、ETCD分布式、seata分布式组件。
3、框架：gateway、OpenFeign、ZK、Dubbo 使用场景和原理
4、缓存和LRU算法
缓存穿透：一定不存在的数据，能直接访问到DB，解决方案：非法请求参数限制、缓存空对象、布隆过滤器
缓存雪崩：大量缓存同时失效或缓存组件故障等，导致大量访问直接到了DB，解决方案：缓存时间加随机数；互斥锁-防止同一数据瞬时的大量访问；限流降级或服务熔断。
缓存击穿：热点数据缓存失效，大并发访问DB
LRU实现：采用HashMap+双向链表实现，redis采用了近似的LRU(随机选择采样数据的值，值越大越接近LRU)，注意，不设置过期时间的不会被移除。
5、容器化技术：主要对象包括：Pod、Service、Deployment、ReplicaSet、ConfigMap、Secret、Volume、StatefulSet、Node、
6、动参重构方面的内容
7、设计模式：单例、工厂模式（简单工厂、工厂方法、抽象工厂模式）创建者Option模式、责任链模式(gin)、适配器模式（slf4j）、装饰器（切面拦截器吗，每层都是一个函数增强）


2025-0605——————————————
1、框架：gateway、OpenFeign、ZK、Dubbo 使用场景和原理
Gateway: 实现：webFlux（响应式编程）+springboot+framework；功能模块：过滤器、路由、断言
Kong:云原生网关，主要包括服务管理、路由、限流
APISIX：云原生网关
OpenFeign：超时重试、自定义重试退避策略、
ZK：主从的分布式架构，存储结构为层次模型（文件系统），临时节点（服务注册的心跳检测）、临时顺序节点（创建同名子节点时会加上序号）、永久节点（配置中心）



2025-0606——————————————
基础：
1、搞清楚java的动态代理、静态代理、反射、类加载、SPI
2、volatile关键字、线程池、AQS
3、spring的依赖注入（DI）和控制反转（IoC）、bean生命周期、bean加载顺序和过程
BeanFactory、InitializingBean、DefinationBean等
4、创建java类的方式有哪些
5、MDC
6、解决bean循环依赖的实现原理：中间加一层缓存（二级缓存），三级缓存解决AOP问题

2025-0607——————————————

1、springboot相关知识点
自动配置原理：EnableAutoConfiguration注解
2、Reactor线程模型，和Netty通信框架的知识
3、BASE和CAP概念和原理：
4、限流、重试、多活、分流、降级、链路追踪（Zipkin、Jaeger），可观测性、监控等
spingcloud、dubbo3

补充：垃圾回收GC、sync、AQS、锁、线程池、分布式缓存、delvops、object对象


2025-0612——————————————
1、volatile、RentrantLock、AQS、CountDownLatch、Semapphore、CyclicBarrier、线程池
2、算法：滚动数组

2025-0618——————————————
动态规划




2025-0702——————————————
自我介绍
项目介绍：网关：架构设计方面（整体接口设计）；扩展性、稳定性、可用性方面（资源隔离、重试、降级/熔断、限流、多级缓存等）

1、golang基础：
Chan：有无缓冲区，以及读取、写入的协程队列，以及环形缓冲区,阻塞/非阻塞的读和写(select+default为非阻塞,其他都是阻塞)
Context：存储有效数据、主动或定时关闭异步协程、父子类上下文
Map: 拉链与开放寻址结合,溢出桶,
Sync.Map
2、日志：zap
3、分布式链路追踪
4、监控



2025-0707——————————————
1、算法：预习滑动窗口
golang


2025-07014——————————————
1、回溯算法：三个案例：复原IP地址、分隔回文串、N皇后
2、信号量以及在其在linux的使用
包括计数信号量、二进制信号
P操作和V操作，多个线程共享资源时，一个线程进行临界区就会执行P操作进行-1，执行完后在进行V操作进行+1
另外一个线程进行时若发现信号量已经<=0则会被挂起等待被唤醒。
3、sync的锁升级过程和原理：https://zhuanlan.zhihu.com/p/290991898
偏向锁：在java的对象头和栈帧中加上threadID标识
轻量级锁：自旋+cas
重量级锁：monitor


2025-07015——————————————
1、算法题：
组合问题、数组总和3

2、java基础题：
信号量、AQS
ReentrantLock：可重入独占锁
Semaphore：信号量，控制同时访问特定资源的线程数量
CountDownLatch：闭锁，允许一个或多个线程等待一组操作完成
ReentrantReadWriteLock：读写锁，允许多个线程同时读，但只允许一个线程写
CyclicBarrier：循环栅栏，允许一组线程相互等待达到一个共同点
2025-07016——————————————
基础知识：
JMM、JVM、Sync原理复习

2025-07017——————————————
1、网络访问
网络七层和四层协议：
四层：应用层，传输层、网络层、（链路层+物理层）
tcp三次握手和四次挥手、沾包问题和解决
浏览器url访问到展示的过程-》DNS解析-〉Nginx->gateway->nacos->services实体->服务实体-》dispatcherServlet->handllMapping->代码逻辑


2025-07020——————————————
面试准备：
golang基础
框架
AI相关


框架相关：
java：spring、springcloud、链路追踪
golang：gin、其他



面试
gateway 认证逻辑？？？


分布式存储：如何存储的

2025-0728——————————————
Golang面试准备：
基础：
Map：内部结构、扩容过程，
扩容机制：增量扩容：kv对/2的B次方>=6.5时会扩容；等量扩容为：小于2的15次方的话，溢出桶比常规桶多就需要等量扩容，大于2的15次方的话，溢出桶的数量只要大于了2的15次方就要等量扩容

切片：内部结构：扩容规则：
预估容量：
若旧容量的2倍扩容后发现小于实际容量，则以实际容量作为扩容后的实际值
其他情况是如果旧的容量原本已经大于1024了，则进行1/4进行扩容，如果小于1024，则还是2倍扩容
分配内存：和实际的元素类型有关系，预告容量*类型大小，找到足够大且接近内存规格的内容：


Context:内部结构和主要功能
：四个结构，六种实现，主要包括多线程间的共享资源，

mysql：redoLog undolog、binlog

Golang内存溢出的常见业务场景和解决办法？
Raft算法逻辑梳理？
角色:leader、follower、candidate
leader读写、follower只读、多数派原则
写入数据时,会先通过leader写入预写日志,然后会进行两阶段提交:向其他节点进行广播进行写请求,follower节点经过验证写入预写日志,并返回leader ack,当超过半数以上,则leader会进行提交请求,并给客户返回写成功

选举:
Leader向follower发送心跳,证明自己还活着,若过期或leader没有续租,则follower会变成candidate进行广播选举
同时会带上任期teamI+index,推动follower的更新进度

写请求时会返回客户端一个最晚的index,,然后客户端访问时某节点后如果发现落后于它,则拒绝访问直接转到其他节点

mysql主从同步:
主节点接受写数据,之后将binlog dump下来,有一个异步监听日志变化,如果有变化,则通知从节点,从节点收到信息后主动从主节点拉去数据
从节点拿到数据后,写入到中继日志中,从节点也有个监听,中继日志有变化后则进行磁盘写入

双主多从-双主在设置自增主键时,步长为2, 主库A从1开始,主库B从2开始,然后在相互之间进行数据同步

半同步模式:主库写入数据后,向所有从库发送写入请求(此时主库事务已提交),然后只要有一个ack就向客户端返回写入成功
半同步无损模式:主库写入数据后,向从库发送写入请求(此时事务未提交),然后只要有一个ack就向客户端返回写入成功(此时才提交)


2025-0813——————————————
预习java的jvm
一个算法题

——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
职业规划:技术深度和拓展、架构思维和业务专长、技术影响力和领导能力
在短期内:
1、继续加强实践能力(多多参与系统的架构设计、服务治理、解决复杂业务问题的能力等);
原生开发、高并发系统或微服务架构.

2、参与开源项目ETCD、dubbo3、Nacos;

最新前沿技术-AI相关—助理秘书等功能

3、锻炼思维能力(数据结构和算法);
4、提及沟通、协作能力

不是一个纯开发者的视角,而是一个做事者的视角-owner精神

问题:

考核制度、薪资构成、定级是什么
——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


针对10月10日的MS的主要技术关键点

1、laaS和paaS的架构设计(云平台)
2、运维方面(linux、CICD、Jenkins、环境部署)
3、云原生方面(docker、k8s、GitOps)
4、数据结构与算法
5、工具或平台的使用(OpenStack、Ansible、阿里云平台)


语言:golang、java、python
数据结构与算法
云原生方面(docker、k8s、CICD)
云平台方面(使用过阿里云的ACK、金山云平台)
任务调度方面(分布式定时器、AI网关的任务调度)


——————————————————————————————————————————————————————————————————————

MS技术
AI相关:langchain、MCP、模型微调


20251111———————
1、CAP: 一致性、可用性、分区容错性
2、BASE: 基本可用,软状态、最终一致性

3、MVCC:

4、一致性模型: 一致性: 强一致性(XA、两阶段提交)、弱一致性、最终一致性(存储的主从集群的异步复制、半同步复制)
5、弱一致性方案:  
顺序一致性
客户端一致性


6、缓存一致性:
读:先查询,有缓冲直接返回,没有则查库,并将结果放到缓冲中
写:先更新数据库,在删除缓存
缓存预热功: 提取将热数据放到缓冲中,避免热流量对系统的冲击

策略:延迟双删策略、增加标识(开关),解决删除缓存到更新数据之间存在的并发问题

7、分布式一致性算法:raft
节点角色(一主多从)、多数派原则、两阶段提交、预写日志(顺序写)、任期、状态机、读写分离
数据同步、领导选举

8、golang内存模型和分配
多级分层:heap、mcentral mcache  67中不同规格的mspanClass


9、表锁、行锁、意向锁、间隙锁

10、GPM:调度和让渡
调度->即为g0从各种地方获取可执行的协程,并将执行权限交给g
让渡->即为g执行结束后(还有其他情况)主动退出执行权限,将其交给g0
让渡除了上面说的结束让度,还包括主动让度(调用runtime.Gosched方法,g变成runable)、阻塞让度(chan或lock被阻塞或者sleep时,g变成waiting)

从g到g0除了让度外,还有抢占的设计:
抢占一般包括系统调用(是指代码里有文件操作或网络操作)和运行超时两种情况
A、由于系统调用会阻塞M,所有会将P和M临时接触绑定关系(存在弱关系,在系统调用后有接回在绑回去),让P可以有机会绑定到其他M(不至于对应的P被阻塞)
B、抢占会对每个p中的g运行情况进行监控,如果超时则直接强占(为g设置抢占标识,通过检查点将g逼停,使其让度给g0),空间不足也会进行抢占

之前抢占的实现手段是给g执行的函数加上抢占标识(协作式抢占),现在是通过信号量实现(主动插入一块代码,让g让度给g0)


11、预习golang基础知识点:
内存溢出场景: 全局缓冲一直增长(LRU)、字符串拼接(strings.builder)、协程序泄露(增加上下文进行超时监听)
使用 pprof 定位内存泄露点
协程 ;读写未初始化的会引发死锁;写已关闭的会发生panic;读已关闭的会继续返回值,没有了就返回零值;重复close会报panic



12、架构设计
13、SQL相关
14、JAVA组件

15、AI相关:MCP langchain、智能体、场景应用和落地





精准: 版本验证、跨系统验证

工作:
准备一个培训文档
本周准备一个关于精准平台的培训


1、trace
2、自定义限流器(多维度自由组合、灵活配置的): 其他限流方案:redis分布式限流、gin限流中间件
本次是一个精细化限流规则,
原理:
1通过参数和配置配置进行匹配,过滤出匹配到的规则数据
2讲符合条件的匹配规则进行排序,通配符越少且越精确,优先级越高
3将匹配到的key放入redis的有序集合
4优化和兼容:token和qps限流统一数据结构
5边检查边裁剪:sum-过期的 就等于符合实际窗口内的所有数据(优化了查询效率)
6还使用了分布式限流+单pod限流

3、自定义熔断器(多维度、熔断时间可控,比较灵活):
将重试后还是失败的放入redis的有序队列中,并且加上熔断时间范围,在范围内,则属于熔断,在范围外,则属于半开状态,将半开状态放到首位,等待被执行
若半开状态的执行后还是失败,则继续放入redis有序队列(时间窗口会放大)

token超限会await(sleep适当释放cpu)
按权重随机获取大模型账号路由


4、重试机制:特定错误码才进行重试
5、资源隔离:账号隔离、专区隔离、任务隔离

6、异步系统:
7、优先级队列设计:基础值(当前时间戳)+多维度的不同权重相加值 在120s内的比值(最小接近0s,最大接近120s)

降级:
依赖的Redis有序队列,若redis挂掉,会启用本地的有序队列,redis挂掉会启用本地有序队列
日志存储降级(异步chan写入由于缓冲区满了而导致失败时,会进行日志存储降级,降级的会进行for select的处理)

8、多层数据模型:本地缓存Map、redis、mysql
多区域共同依赖puslar,各自有独立的redis,本地通过实时将redis数据同步到本地缓存
UML类图(面向对象设计)

9、任务队列监控
任务执行状态(CounterOpts),同时在处理任务(GaugeOpts)、任务处理占用时间(直方图)


10、分布式锁
加锁、释放锁(增加锁标识,写成key+ID),保证自己的锁只能自己释放

配置文件加载顺序: 本地配置<配置中心<环境变量
Apollo配置、公共配置、独有配置

11、AI: eino、langchain

2025-11-18
1、回顾较久之前的算法题
2、把对象池原理搞清楚、Gin框架
3、准备周四的MS
4、简单的python语法基础


精通java和golang



