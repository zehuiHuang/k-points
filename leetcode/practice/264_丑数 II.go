package practice

/*
*
给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是质因子只包含 2、3 和 5 的正整数。
*/

/*
*
思路:
概念:最小丑树为1,每个丑数对 2,3,5相乘后任然为丑数

第一种算法比较简单直接,将最小丑数放入小顶推,每次取小顶堆的值,然后分别与 2 、3 、5相乘然后放入堆中,在取最小,取n次即为答案(放入堆时要去重)

第二种方式:理解如下:
dp[i]肯定是其前面的某个数乘以 2 （或乘以 3、乘以 5）得出来的，而dp[i] x 2 、dp[i] x 3、dp[i] x 5 这三个数，肯定也是dp 数组后面某个位置的数。
那就可以推断出来，dp这个数组上的数，每个位置肯定都要x2\x3\x5 一遍，其结果是放在dp 数组后面某个位置。
那我们就可以从这个数组初始的状态，即dp[1]=1 开始，用p2\p3\p5 表示当前该哪个位置该乘以2\3\5 了。我们只要每次取乘以 2、3、5 后的结果中最小的值，
那这个最小的值就是最新一个的dp 值，然后相应地移动一下计算出这个新dp 值的 p2（或 p3 或p5）索引，即该下一个数去乘以2（或3 或5）了。
按次遍历，计算出第i个数，即为dp[i]
*/
func nthUglyNumber(n int) int {
	//1,2,3,4,5,6,8,9,10,12
	//dp[i]表示第i个丑数
	dp := make([]int, n+1)
	//dp[0]没意义,从1开始 1是最小的丑数
	dp[1] = 1
	p2, p3, p5 := 1, 1, 1
	for i := 2; i < n+1; i++ {
		//更简答的理解:开始时指向同一个最初值,后面的可能是乘2乘3乘5,如果选中的最小值已经放到dp[i]中了,那么乘2的下次就没必要在乘2了
		//只能是dp下一个索引位置再乘2,之前乘3、乘5的最小值没选到的(比当前值大),还要继续等待被选
		n2 := dp[p2] * 2
		n3 := dp[p3] * 3
		n5 := dp[p5] * 5
		//找到最小丑数
		dp[i] = min(min(n2, n3), n5)
		if n2 == dp[i] {
			p2++
		}
		if n3 == dp[i] {
			p3++
		}
		if n5 == dp[i] {
			p5++
		}
	}
	return dp[n]
}
